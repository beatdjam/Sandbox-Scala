import scala.language.postfixOps
// 5 基本型と演算子

// 5.1  基本型
// Byte,Short,Int,Long,Charを整数値型
// Float,Doubleを数値型と呼ぶ
// 基本型のうちStringだけはjava.langパッケージに属していて、その他は全部scalaパッケージに含まれている

// 5.2 リテラル
// Scalaシェルは整数値の初期化のためにどの形式のリテラル表現を使っても必ず10進数で表示する

// raw string
// """で囲んだ文字列はraw stringとして扱える(Kotlinと同じ？)
// 各行の先頭にパイプ文字を入れてstripMarginメソッドを呼び出すとパイプの位置を行頭として扱うことができる
println(
  """Hello,
     World
""")
println(
  """|Hello,
     |World
""".stripMargin)

// シンボルリテラル
// `ident　のような形で書かれるものをシンボルリテラルと呼ぶ
// シンボルリテラルは英数字から構成される任意の識別子である
// 最新のScalaではSymbol("ident")のように記述する

// シンボルリテラルは、同じ値を扱うときに同じ実体を参照する
// 識別子として文字列を定義したいときなどに使うっぽい？

// 5.3 文字列補間
// s文字列補間子(string interpolator)を使って変数を展開した文字列を生成する
val name = "Taro"
println(s"Hello, $name!")
println(s"Hello, ${name.toUpperCase}!")
// 他にもraw, fがある
// rawは文字列リテラルのエスケープシーケンスを認識しない(=そのままの文字列を出力する)
println(s"string\\\\")
println(raw"raw\\\\")
// fはprintfと同じ形式で後ろにつけた文字列に応じて書式設定を行うことができる
// 何もつけなければsと同じように振る舞う
println(f"${math.Pi}%.10f")
println(f"${math.Pi}")
println(s"${math.Pi}")
// 文字列指定子はライブラリやユーザーが定義することもできる

// 5.4 演算子はメソッドである
// 下記は等価であり、中置演算子は実際にはInt.+を呼び出している
val sum = 1 + 2
val sum2 = 1.+(2)

// Scalaにおいて、演算子は特別な構文ではなく、メソッド呼び出しの仕組みとして用意されている
// つまりどのメソッドでも演算子のように書くことができる
val s = "Hello"
s indexOf "e"
s indexOf ("e", 2)

// 前置、後置演算子も定義することができる
// 中置演算子は複数の項を取ることができるのに対して、これらは単項演算子になる
// 前置演算子として利用できるのは + - ! ~ のみである
// unary_- や unary_+ などの形で定義されたメソッドを呼び出す
-2  == 2.unary_-

// 後置演算子は. や括弧をつけずに呼び出される引数なしのメソッド
// 慣習的に、メソッドが副作用をもつ場合は()をつけて呼び出され、
// 副作用がない場合は括弧を省略して呼び出される
println(s)
s toLowerCase
s.toLowerCase

// 演算子はメソッドだが、名前渡しパラメータの機能を利用することによって短絡評価を実現している

// 5.8 オブジェクトの等価性
// ==や!=はすべてのオブジェクトに適用できる
// Listでも中の値の等価性を評価できるし、異なる型やnullとの比較もできる

// 5.10 リッチラッパー
// Scalaの基本型には、追加メソッドを提供するリッチラッパーが存在する
